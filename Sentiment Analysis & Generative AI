library(shiny)
library(shinydashboard)
library(DT)
library(httr)
library(sentimentr)
library(ggplot2)
library(tm)
library(wordcloud)
library(RColorBrewer)
library(syuzhet)

# Assuming dfCardio dataset is pre-loaded
# dfCardio <- read.csv("path_to_your_dfCardio.csv")  # Uncomment and adapt to load your dataset

ui <- dashboardPage(
  dashboardHeader(title = "Chatbot with Sentiment Analysis", titleWidth = 300),
  dashboardSidebar(
    sidebarMenu(
      menuItem("Introduction", tabName = "introduction", icon = icon("info-circle")),
      menuItem("CVD Questions", tabName = "cvd_questions", icon = icon("question-circle")),
      menuItem("Chat", tabName = "chat", icon = icon("comments")),
      menuItem("Sentiment & Emotion", tabName = "sentiment_emotion", icon = icon("chart-line")),
      menuItem("Metrics", tabName = "metrics", icon = icon("tachometer-alt")),
      menuItem("Word Cloud", tabName = "word_cloud", icon = icon("cloud")),
      menuItem("Emotion Score Consistency", tabName = "emotion_consistency", icon = icon("balance-scale")),
      menuItem("Emotion Detection Accuracy", tabName = "emotion_accuracy", icon = icon("check-square"))
    ),
    width = 250
  ),
  dashboardBody(
    tags$head(
      tags$style(HTML("
        .box {
          border-radius: 10px;
        }
        .content-wrapper {
          background: #f4f6f9;
        }
        .shiny-input-container {
          margin-bottom: 10px;
        }
      "))
    ),
    tabItems(
      tabItem(tabName = "introduction",
              fluidRow(
                box(
                  title = "Cardiovascular Health Overview", width = 12, status = "primary", solidHeader = TRUE,
                  p("The dfCardio dataset includes key features such as age, cholesterol levels, and blood pressure, which can be influential in predicting anxiety and stress related to cardiovascular disease progression."),
                  p("These emotional states may be inferred based on certain physical indicators and social history."),
                  dataTableOutput("cardioData")
                )
              )
      ),
      tabItem(tabName = "cvd_questions",
              fluidRow(
                box(
                  title = "CVD Personal Questions", width = 12, status = "primary", solidHeader = TRUE,
                  actionButton("generateQuestionsBtn", "Do you want to answer 10 questions?", 
                               class = "btn-success btn-lg", style = "width: 100%;"),
                  textOutput("currentQuestion"),
                  textInput("answerInput", "Your answer:", ""),
                  actionButton("nextQuestionBtn", "Next Question", 
                               class = "btn-success btn-lg", style = "width: 100%;")
                )
              )
      ),
      tabItem(tabName = "chat",
              fluidRow(
                box(
                  title = "Chatbot", width = 12, status = "primary", solidHeader = TRUE,
                  textInput("userInput", "Type your message:", ""),
                  actionButton("generateBtn", "Send",
                               class = "btn-primary btn-lg",
                               style = "width: 100%;"),
                  dataTableOutput("chatOutput"),
                  tags$style(HTML("#chatOutput { height: 400px; }"))
                )
              )
      ),
      tabItem(tabName = "sentiment_emotion",
              fluidRow(
                box(
                  title = "Sentiment & Emotion Visualization", width = 12, status = "primary", solidHeader = TRUE,
                  plotOutput("sentimentCountPlot", height = "300px"),
                  plotOutput("emotionCountPlot", height = "300px"),
                  plotOutput("sentimentScorePlot", height = "300px"),
                  plotOutput("sentimentLinePlot", height = "300px"),
                  plotOutput("cumulativeSentimentPlot", height = "300px")
                )
              )
      ),
      tabItem(tabName = "metrics",
              fluidRow(
                box(
                  title = "Dashboard Summary", width = 12, status = "primary", solidHeader = TRUE,
                  p("Summary of key metrics from chat interactions."),
                  textOutput("avgSentimentScore"),
                  textOutput("mostFrequentEmotion"),
                  textOutput("totalMessages"),
                  textOutput("sentimentCounts")
                )
              )
      ),
      tabItem(tabName = "word_cloud",
              fluidRow(
                box(
                  title = "Word Cloud", width = 12, status = "primary", solidHeader = TRUE,
                  plotOutput("wordCloudPlot", height = "600px")
                )
              )),
      tabItem(tabName = "emotion_consistency",
              fluidRow(
                box(
                  title = "Emotion Score Consistency", width = 12, status = "primary", solidHeader = TRUE,
                  plotOutput("emotionConsistencyPlot", height = "300px")
                )
              )),
      tabItem(tabName = "emotion_accuracy",
              fluidRow(
                box(
                  title = "Emotion Detection Accuracy", width = 12, status = "primary", solidHeader = TRUE,
                  plotOutput("confusionMatrixPlot", height = "300px")
                )
              ))
    )
  )
)

server <- function(input, output, session) {
  # Display dfCardio dataset
  output$cardioData <- renderDataTable({
    DT::datatable(
      dfCardio,
      options = list(paging = TRUE, searching = TRUE),
      rownames = FALSE,
      class = 'cell-border stripe',
      escape = FALSE
    )
  })

  # Initialize chat history
  chat_history <- reactiveVal(data.frame(Role = character(), Message = character(),
                                         Sentiment = character(), Score = numeric(),
                                         Emotion = character(), stringsAsFactors = FALSE))

  # Keep track of the number of responses
  response_count <- reactiveVal(0)

  # Initialize CVD questions
  cvd_questions <- reactiveVal(NULL)
  current_question_index <- reactiveVal(1)
  
  # Log for when questions should be generated
  generate_questions <- reactiveVal(FALSE)

  # Function to generate CVD Questions
  generateCVDQuestions <- function(api_key) {
    prompt <- "Generate 10 personalized questions related to ID, AGE, SYSTOLIC, DIASTOLIC BP, SMOKING, DRINKING, CHOLESTROL, GLUCOSE, AND IF U ARE ACTIVE."
    return(unlist(strsplit(generateContent(prompt, api_key), "\n")))
  }

  # Generate content from chatbot and perform sentiment analysis
  observeEvent(input$generateBtn, {
    user_text <- input$userInput
    api_key <- "YOUR_API_KEY_HERE"  # Replace with your actual API key
    
    if (user_text != "" && response_count() < 10) {
      # Generate response based on user input
      response <- generateContent(user_text, api_key)
      
      # Perform sentiment analysis on user input
      user_sentiment_score <- sentimentr::sentiment(user_text)$sentiment
      user_sentiment_label <- ifelse(mean(user_sentiment_score) > 0, "Positive", 
                                      ifelse(mean(user_sentiment_score) < 0, "Negative", "Neutral"))
      user_score <- min(max(mean(user_sentiment_score), -1), 1)
      
      # Perform emotion detection on user input
      user_emotions <- get_nrc_sentiment(user_text)
      user_emotion_index <- which(user_emotions[1, ] == max(user_emotions[1, ]))
      user_emotion_label <- if (length(user_emotion_index) > 0) colnames(user_emotions)[user_emotion_index[1]] else NA
      
      # Perform sentiment analysis on the chatbot's response
      sentiment_score <- sentimentr::sentiment(response)$sentiment
      sentiment_label <- ifelse(mean(sentiment_score) > 0, "Positive", 
                                ifelse(mean(sentiment_score) < 0, "Negative", "Neutral"))
      response_score <- min(max(mean(sentiment_score), -1), 1)
      
      # Perform emotion detection on chatbot's response
      response_emotions <- get_nrc_sentiment(response)
      response_emotion_index <- which(response_emotions[1, ] == max(response_emotions[1, ]))
      response_emotion_label <- if (length(response_emotion_index) > 0) colnames(response_emotions)[response_emotion_index[1]] else NA
      
      # Update chat history
      updated_history <- rbind(chat_history(), 
                               data.frame(Role = "User", Message = user_text, Sentiment = user_sentiment_label, 
                                          Score = user_score, Emotion = user_emotion_label, 
                                          stringsAsFactors = FALSE), 
                               data.frame(Role = "Model", Message = response, Sentiment = sentiment_label, 
                                          Score = response_score, Emotion = response_emotion_label, 
                                          stringsAsFactors = FALSE))
      chat_history(updated_history)
      
      # Update response count
      response_count(response_count() + 1)
      
      # Render updated chat output
      output$chatOutput <- renderDataTable({
        DT::datatable(
          chat_history(),
          options = list(paging = FALSE, searching = FALSE),
          rownames = FALSE,
          class = 'cell-border stripe',
          escape = FALSE
        )
      })

      # Update metrics
      output$avgSentimentScore <- renderText({
        avg_score <- mean(chat_history()$Score)
        paste("Average Sentiment Score:", round(avg_score, 2))
      })
      
      output$mostFrequentEmotion <- renderText({
        emotion_counts <- table(chat_history()$Emotion)
        most_frequent <- names(emotion_counts)[which.max(emotion_counts)]
        paste("Most Frequently Discussed Emotion:", most_frequent)
      })
      
      output$totalMessages <- renderText({
        paste("Total Messages Exchanged:", nrow(chat_history()))
      })
      
      output$sentimentCounts <- renderText({
        sentiment_counts <- table(chat_history()$Sentiment)
        sentiment_summary <- paste(names(sentiment_counts), ":", as.vector(sentiment_counts), collapse = ", ")
        paste("Sentiment Counts:", sentiment_summary)
      })

      # Render the sentiment count plot
      output$sentimentCountPlot <- renderPlot({
        sentiment_data <- data.frame(Sentiment = chat_history()$Sentiment)
        ggplot(sentiment_data, aes(x = Sentiment, fill = Sentiment)) +
          geom_bar(aes(y = ..count..), position="dodge") +
          labs(title = "Sentiment Count Distribution", x = "Sentiment", y = "Count") +
          theme_minimal() + theme(legend.position = "bottom")
      })
      
      # Render the emotion count plot
      output$emotionCountPlot <- renderPlot({
        emotions_list <- table(chat_history()$Emotion)
        emotion_counts_df <- data.frame(Emotion = names(emotions_list), Count = as.numeric(emotions_list))
        
        # Render the plot only if there are emotions counted
        if (nrow(emotion_counts_df) > 0) {
          ggplot(emotion_counts_df, aes(x = reorder(Emotion, -Count), y = Count, fill = Emotion)) +
            geom_bar(stat = "identity") +
            labs(title = "Emotion Count Distribution", x = "Emotion", y = "Count") +
            theme_minimal() + theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")
        }
      })
      
      # Render the sentiment score plot
      output$sentimentScorePlot <- renderPlot({
        sentiment_data <- data.frame(Role = factor(chat_history()$Role), Score = chat_history()$Score)
        ggplot(sentiment_data, aes(x = Role, y = Score, fill = Role)) +
          geom_boxplot() +
          labs(title = "Sentiment Scores by Role", x = "Role", y = "Sentiment Score") +
          theme_minimal() + theme(legend.position = "bottom")
      })
      
      # Render the sentiment line plot
      output$sentimentLinePlot <- renderPlot({
        sentiment_scores <- data.frame(
          Count = 1:nrow(chat_history()),
          Score = chat_history()$Score
        )
        ggplot(sentiment_scores, aes(x = Count, y = Score)) +
          geom_line(color = "blue") +
          geom_point(size = 2, color = "red") +
          labs(title = "Sentiment Score Trend", x = "Message Count", y = "Sentiment Score") +
          theme_minimal()
      })
      
      # Render the cumulative sentiment plot
      output$cumulativeSentimentPlot <- renderPlot({
        cumulative_scores <- cumsum(chat_history()$Score)
        ggplot(data.frame(Count = 1:length(cumulative_scores), CumulativeScore = cumulative_scores), aes(x = Count, y = CumulativeScore)) +
          geom_line(color = "green") +
          geom_point(size = 2, color = "orange") +
          labs(title = "Cumulative Sentiment Score Trend", x = "Message Count", y = "Cumulative Sentiment Score") +
          theme_minimal()
      })
      
      updateTextInput(session, "userInput", value = "")
    } else if (response_count() >= 10) {
      # Display message if more than 10 responses have been entered
      showModal(modalDialog(
        title = "Limit Reached",
        "You have entered 10 responses. The analysis is complete.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })

  # Start generating questions based on user input
  observeEvent(input$generateQuestionsBtn, {
    api_key <- "YOUR_API_KEY_HERE" # Replace with your API key
    if (!generate_questions()) {
      cvd_questions(generateCVDQuestions(api_key))
      generate_questions(TRUE)
      current_question_index(1)

      # Initial question display
      output$currentQuestion <- renderText({
        cvd_questions()[current_question_index()]
      })
    } else {
      showModal(modalDialog(
        title = "Questions Already Generated",
        "You have already chosen to answer the questions.",
        easyClose = TRUE,
        footer = NULL
      ))
    }
  })
  
  # Get the next question
  observeEvent(input$nextQuestionBtn, {
    if (generate_questions()) {
      answer <- input$answerInput
      
      if (answer != "") {
        # Process the answer - for now just printing to console
        print(paste("User answered: ", answer))
        current_question_index(current_question_index() + 1)
        updateTextInput(session, "answerInput", value = "")
      }
      
      # Update the question to display
      output$currentQuestion <- renderText({
        if (current_question_index() <= length(cvd_questions())) {
          cvd_questions()[current_question_index()]
        } else {
          "Thank you for answering the questions!"
        }
      })
    }
  })
  
  # Create and render the word cloud
  output$wordCloudPlot <- renderPlot({
    # Combine all messages into a single text corpus
    messages <- paste(chat_history()$Message, collapse = " ")
    messages_corpus <- Corpus(VectorSource(messages))
    messages_corpus <- tm_map(messages_corpus, content_transformer(tolower))
    messages_corpus <- tm_map(messages_corpus, removePunctuation)
    messages_corpus <- tm_map(messages_corpus, removeNumbers)
    messages_corpus <- tm_map(messages_corpus, removeWords, stopwords("en"))
    
    # Create a term-document matrix
    tdm <- TermDocumentMatrix(messages_corpus)
    matrix <- as.matrix(tdm)
    word_freqs <- sort(rowSums(matrix), decreasing = TRUE)
    word_freqs_df <- data.frame(word = names(word_freqs), freq = word_freqs)
    
    # Generate the word cloud
    wordcloud(words = word_freqs_df$word, freq = word_freqs_df$freq, min.freq = 1, max.words = 100, random.order = FALSE, rot.per = 0.35, colors = brewer.pal(8, "Dark2"))
  })
  
  # Render the Emotion Score Consistency plot
  output$emotionConsistencyPlot <- renderPlot({
    if (nrow(chat_history()) > 1) {
      consistency_data <- data.frame(
        UserEmotion = chat_history()$Emotion[chat_history()$Role == "User"],
        ModelEmotion = chat_history()$Emotion[chat_history()$Role == "Model"]
      )
      
      # Convert emotions to a factor
      consistency_data <- na.omit(consistency_data)
      consistency_data$UserEmotion <- factor(consistency_data$UserEmotion)
      
      ggplot(consistency_data, aes(x = UserEmotion, fill = ModelEmotion)) +
        geom_bar(position = "fill") +
        labs(title = "Model Response Emotion Consistency", x = "User Emotion", y = "Proportion") +
        theme_minimal() + theme(legend.position = "right")
    } else {
      # If there's not enough data, show a placeholder message
      plot.new()
      text(0.5, 0.5, "Not enough data to display consistency.", cex = 1.5)
    }
  })
  
  # Render the Confusion Matrix for Emotion Detection
  output$confusionMatrixPlot <- renderPlot({
    confusion_matrix <- calculate_accuracy()
    
    if (!is.null(confusion_matrix)) {
      ggplot(as.data.frame(confusion_matrix), aes(x = Actual, y = Predicted)) +
        geom_tile(aes(fill = Freq), color = "white") +
        scale_fill_gradient(low = "white", high = "blue") +
        geom_text(aes(label = Freq), vjust = 1) +
        labs(title = "Confusion Matrix for Emotion Detection", x = "Actual Emotion", y = "Predicted Emotion") +
        theme_minimal() +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    } else {
      plot.new()
      text(0.5, 0.5, "Not enough data to display the confusion matrix.", cex = 1.5)
    }
  })

  # Function to calculate accuracy metrics
  calculate_accuracy <- function() {
    if (nrow(chat_history()) > 1) {
      confusion_matrix <- table(Actual = chat_history()$Emotion[chat_history()$Role == "User"],
                                 Predicted = chat_history()$Emotion[chat_history()$Role == "Model"])
      return(confusion_matrix)
    } else {
      return(NULL)
    }
  }
}

# Function to generate content (response from model)
generateContent <- function(prompt, api_key) {
  headers <- c(`Content-Type` = "application/json")
  params <- list(`key` = api_key)
  data <- sprintf('{"contents": [{"parts":[{"text": "%s"}]}]}', prompt)
  res <- httr::POST(
    url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent",
    httr::add_headers(.headers = headers),
    query = params,
    body = data
  )
  
  # Check if the response is valid and then return the results
  if (httr::status_code(res) == 200) {
    response_content <- httr::content(res)
    if (length(response_content$candidates) > 0 && length(response_content$candidates[[1]]$content$parts) > 0) {
      return(response_content$candidates[[1]]$content$parts[[1]]$text)
    } else {
      return("Error: No valid response content.")
    }
  } else {
    return(paste("Error:", httr::status_code(res), httr::content(res, as = "text")))
  }
}

# Run the application
shinyApp(ui = ui, server = server)
